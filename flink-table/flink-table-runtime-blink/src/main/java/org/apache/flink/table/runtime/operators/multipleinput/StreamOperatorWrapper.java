/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.table.runtime.operators.multipleinput;

import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.streaming.api.operators.BoundedMultiInput;
import org.apache.flink.streaming.api.operators.BoundedOneInput;
import org.apache.flink.streaming.api.operators.SetupableStreamOperator;
import org.apache.flink.streaming.api.operators.StreamOperator;
import org.apache.flink.streaming.api.operators.StreamOperatorFactory;
import org.apache.flink.streaming.api.operators.StreamOperatorParameters;
import org.apache.flink.streaming.runtime.tasks.ProcessingTimeServiceAware;
import org.apache.flink.table.data.RowData;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import static org.apache.flink.util.Preconditions.checkArgument;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * This class handles the close, endInput and other related logic of a {@link StreamOperator}.
 * It also automatically propagates the end-input operation to the next wrapper that the {@link #outputs}
 * points to, so we only need to call the head wrapper's {@link #endOperatorInput(int)} method.
 */
public class StreamOperatorWrapper<OP extends StreamOperator<RowData>> implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * The factory to create the wrapped operator.
	 */
	private final StreamOperatorFactory<RowData> factory;

	/**
	 * the operator name for debug
	 */
	private final String name;

	/**
	 * The type info of this wrapped operator's all inputs.
	 *
	 * <p><strong>NOTE:<strong/> The inputs of an operator may not all be in the multiple input operator, e.g.
	 * The multiple input operator contains A and J, and A is one of the input of J,
	 * and another input of J is not in the multiple input operator.
	 * <pre>
	 * -------
	 *        \
	 *         J --
	 *        /
	 * -- A --
	 * </pre>
	 * For this example, `allInputTypes` contains two input types.
	 */
	private final List<TypeInformation<?>> allInputTypes;

	/**
	 * The total input count of this wrapped operator. (see the above example)
	 */
	private final int totalInputCount;

	/**
	 * The type info of this wrapped operator's output
	 */
	private final TypeInformation<?> outputType;

	/**
	 * The input wrappers of this operator wrapper
	 */
	private final List<StreamOperatorWrapper<?>> inputs;

	/**
	 * The input id corresponding to each input operator.
	 * e.g., input id may be 1 or 2 for join operator.
	 */
	private final List<Integer> inputId;

	/**
	 * The output wrapper of this operator wrapper
	 */
	private final List<StreamOperatorWrapper<?>> outputs;

	/**
	 * The wrapped operator, which will be generated by {@link #factory}.
	 */
	private transient OP wrapped;

	private boolean closed;
	private int endedInputCount;

	public StreamOperatorWrapper(
			StreamOperatorFactory<RowData> factory,
			String name,
			List<TypeInformation<?>> allInputTypes,
			TypeInformation<?> outputType) {
		this.factory = checkNotNull(factory);
		this.name = checkNotNull(name);
		this.outputType = checkNotNull(outputType);

		this.allInputTypes = checkNotNull(allInputTypes);
		this.totalInputCount = allInputTypes.size();

		this.inputs = new ArrayList<>();
		this.inputId = new ArrayList<>();

		this.outputs = new ArrayList<>();

		this.endedInputCount = 0;
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void createOperator(StreamOperatorParameters<RowData> parameters) {
		checkArgument(wrapped == null, "This operator has been initialized");
		if (factory instanceof ProcessingTimeServiceAware) {
			((ProcessingTimeServiceAware) factory).setProcessingTimeService(parameters.getProcessingTimeService());
		}
		wrapped = factory.createStreamOperator(parameters);
		if (wrapped instanceof SetupableStreamOperator) {
			((SetupableStreamOperator) wrapped).setup(
					parameters.getContainingTask(), parameters.getStreamConfig(), parameters.getOutput());
		}
	}

	public void endOperatorInput(int inputId) throws Exception {
		endedInputCount++;
		if (wrapped instanceof BoundedOneInput) {
			((BoundedOneInput) wrapped).endInput();
			endOperatorInputForOutput();
		} else if (wrapped instanceof BoundedMultiInput) {
			((BoundedMultiInput) wrapped).endInput(inputId);
			if (endedInputCount >= totalInputCount) {
				endOperatorInputForOutput();
			}
		} else {
			// some batch operators do not extend from BoundedOneInput, such as BatchCalc
			endOperatorInputForOutput();
		}
	}

	private void endOperatorInputForOutput() throws Exception {
		for (int i = 0; i < outputs.size(); ++i) {
			StreamOperatorWrapper<?> output = outputs.get(i);
			int inputId = getInputId(output);
			output.endOperatorInput(inputId);
		}
	}

	/**
	 * Return the input id (start from 1) of this wrapper corresponding to the given output.
	 */
	public int getInputId(StreamOperatorWrapper<?> output) {
		List<StreamOperatorWrapper<?>> inputs = output.getInputs();
		for (int i = 0; i < inputs.size(); ++i) {
			if (inputs.get(i) == this) {
				return output.inputId.get(i);
			}
		}
		throw new RuntimeException("This should not happen.");
	}

	public OP getStreamOperator() {
		return checkNotNull(wrapped);
	}

	public List<TypeInformation<?>> getAllInputTypes() {
		return allInputTypes;
	}

	public TypeInformation<?> getOutputType() {
		return outputType;
	}

	public void addInput(StreamOperatorWrapper<?> input, int inputId) {
		this.inputs.add(input);
		this.inputId.add(inputId);
	}

	public void addOutput(StreamOperatorWrapper<?> output) {
		this.outputs.add(output);
	}

	public List<StreamOperatorWrapper<?>> getInputs() {
		return inputs;
	}

	public List<StreamOperatorWrapper<?>> getOutputs() {
		return outputs;
	}

	/**
	 * Checks if the wrapped operator has been closed.
	 *
	 * <p>Note that this method must be called in the task thread.
	 */
	public boolean isClosed() {
		return closed;
	}

	public void close() throws Exception {
		if (isClosed()) {
			return;
		}
		closed = true;
		wrapped.close();
	}

	@Override
	public String toString() {
		return name;
	}
}
