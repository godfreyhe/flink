/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.table.runtime.operators.multipleinput;

import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.streaming.api.operators.BoundedMultiInput;
import org.apache.flink.streaming.api.operators.BoundedOneInput;
import org.apache.flink.streaming.api.operators.SetupableStreamOperator;
import org.apache.flink.streaming.api.operators.StreamOperator;
import org.apache.flink.streaming.api.operators.StreamOperatorFactory;
import org.apache.flink.streaming.api.operators.StreamOperatorParameters;
import org.apache.flink.streaming.runtime.tasks.ProcessingTimeServiceAware;
import org.apache.flink.table.data.RowData;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static org.apache.flink.util.Preconditions.checkArgument;
import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * This class handles the close, endInput and other related logic of a {@link StreamOperator}.
 * It also automatically propagates the end-input operation to the next wrapper that the {@link #outputs}
 * points to, so we only need to call the head wrapper's {@link #endOperatorInput(int)} method.
 */
public class StreamOperatorWrapper<OP extends StreamOperator<RowData>> implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * The factory to create the wrapped operator.
	 */
	private final StreamOperatorFactory<RowData> factory;

	/**
	 * the operator name for debug
	 */
	private final String name;

	/**
	 * The type info of this wrapped operator's all inputs.
	 *
	 * <p><strong>NOTE:<strong/> The inputs of an operator may not all be in the multiple input operator, e.g.
	 * The multiple input operator contains A and J, and A is one of the input of J,
	 * and another input of J is not in the multiple input operator.
	 * <pre>
	 * -------
	 *        \
	 *         J --
	 *        /
	 * -- A --
	 * </pre>
	 * For this example, `allInputTypes` contains two input types.
	 */
	private final List<TypeInformation<?>> allInputTypes;

	/**
	 * The total input count of this wrapped operator. (see the above example)
	 */
	private final int totalInputCount;

	/**
	 * The type info of this wrapped operator's output
	 */
	private final TypeInformation<?> outputType;

	/**
	 * Managed memory fraction in multiple input operator
	 */
	private double managedMemoryFraction = -1;

	/**
	 * The input edges of this operator wrapper, the edges' targets is this instance.
	 */
	private final List<Edge> inputEdges;

	/**
	 * The output edges of this operator wrapper, the edges' sources is this instance.
	 */
	private final List<Edge> outputEdges;

	/**
	 * The wrapped operator, which will be generated by {@link #factory}.
	 */
	private transient OP wrapped;

	private boolean closed;
	private int endedInputCount;

	public StreamOperatorWrapper(
			StreamOperatorFactory<RowData> factory,
			String name,
			List<TypeInformation<?>> allInputTypes,
			TypeInformation<?> outputType) {
		this.factory = checkNotNull(factory);
		this.name = checkNotNull(name);
		this.outputType = checkNotNull(outputType);

		this.allInputTypes = checkNotNull(allInputTypes);
		this.totalInputCount = allInputTypes.size();

		this.inputEdges = new ArrayList<>();
		this.outputEdges = new ArrayList<>();

		this.endedInputCount = 0;
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void createOperator(StreamOperatorParameters<RowData> parameters) {
		checkArgument(wrapped == null, "This operator has been initialized");
		if (factory instanceof ProcessingTimeServiceAware) {
			((ProcessingTimeServiceAware) factory).setProcessingTimeService(parameters.getProcessingTimeService());
		}
		wrapped = factory.createStreamOperator(parameters);
		if (wrapped instanceof SetupableStreamOperator) {
			((SetupableStreamOperator) wrapped).setup(
					parameters.getContainingTask(), parameters.getStreamConfig(), parameters.getOutput());
		}
	}

	public void endOperatorInput(int inputId) throws Exception {
		endedInputCount++;
		if (wrapped instanceof BoundedOneInput) {
			((BoundedOneInput) wrapped).endInput();
			endOperatorInputForOutput();
		} else if (wrapped instanceof BoundedMultiInput) {
			((BoundedMultiInput) wrapped).endInput(inputId);
			if (endedInputCount >= totalInputCount) {
				endOperatorInputForOutput();
			}
		} else {
			// some batch operators do not extend from BoundedOneInput, such as BatchCalc
			endOperatorInputForOutput();
		}
	}

	private void endOperatorInputForOutput() throws Exception {
		for (Edge edge : outputEdges) {
			edge.target.endOperatorInput(edge.inputId);
		}
	}

	public OP getStreamOperator() {
		return checkNotNull(wrapped);
	}

	public List<TypeInformation<?>> getAllInputTypes() {
		return allInputTypes;
	}

	public TypeInformation<?> getOutputType() {
		return outputType;
	}

	/**
	 * This method is only used to
	 */
	public void addInput(StreamOperatorWrapper<?> input, int inputId) {
		Edge edge = new Edge(input, this, inputId);
		this.inputEdges.add(edge);
		input.outputEdges.add(edge);
	}

	public void setManagedMemoryFraction(double managedMemoryFraction) {
		this.managedMemoryFraction = managedMemoryFraction;
	}

	public double getManagedMemoryFraction() {
		return managedMemoryFraction;
	}

	public List<Edge> getInputEdges() {
		return inputEdges;
	}

	public List<StreamOperatorWrapper<?>> getInputWrappers() {
		return inputEdges.stream().map(Edge::getSource).collect(Collectors.toList());
	}

	public List<Edge> getOutputEdges() {
		return outputEdges;
	}

	public List<StreamOperatorWrapper<?>> getOutputWrappers() {
		return outputEdges.stream().map(Edge::getTarget).collect(Collectors.toList());
	}

	/**
	 * Checks if the wrapped operator has been closed.
	 *
	 * <p>Note that this method must be called in the task thread.
	 */
	public boolean isClosed() {
		return closed;
	}

	public void close() throws Exception {
		if (isClosed()) {
			return;
		}
		closed = true;
		wrapped.close();
	}

	@Override
	public String toString() {
		return name;
	}

	/**
	 * The edge connects two {@link StreamOperatorWrapper}s.
	 */
	public static class Edge  implements Serializable {
		private static final long serialVersionUID = 1L;

		private final StreamOperatorWrapper<?> source;
		private final StreamOperatorWrapper<?> target;
		/**
		 * The input id (start from 1) corresponding to the target's inputs.
		 * e.g. the target is a join operator, depending on the side of the source,
		 * input id may be 1 (left side) or 2 (right side).
		 */
		private final int inputId;

		public Edge(StreamOperatorWrapper<?> source, StreamOperatorWrapper<?> target, int inputId) {
			this.source = source;
			this.target = target;
			this.inputId = inputId;
		}

		public StreamOperatorWrapper<?> getSource() {
			return source;
		}

		public StreamOperatorWrapper<?> getTarget() {
			return target;
		}

		public int getInputId() {
			return inputId;
		}

		@Override
		public String toString() {
			return "Edge{" +
					"source=" + source +
					", target=" + target +
					", inputId=" + inputId +
					'}';
		}
	}

}
